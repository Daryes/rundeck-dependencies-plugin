#!/bin/bash
# -------------------------------------------------------------------------------------------
# Script for waiting for another job, allowing to create a dependency between them
# A token with read access to the Rundeck API is required
#
# integrated self-help
# -------------------------------------------------------------------------------------------
# 2017/07/09    AHZ creation


# External variables
# RD_JOB_SERVERURL=<generated by rundeck>
# DEPENDENCY_IGNORE=<optional, empty or "anything non blank" >
# RD_FLOW_DAILY_START=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg>
# RD_FLOW_DAILY_END=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg >
# RD_TMP_DIR=<optional or path to the Rundeck tmp dir>
# RD_JOB_FILTER=<generated by rundeck when a job is ran on specific nodes>

# External file
PLUGIN_CONF_FILE=/etc/rundeck/plugin-dependencies.conf
[ -s $PLUGIN_CONF_FILE ] && RD_TOKEN=$( cat $PLUGIN_CONF_FILE 2>&1| tr -d '\n' )

# default values
TARGET_PROJECT_NAME=""
TARGET_GROUP_NAME=""
TARGET_JOB_NAME=""
TARGET_JOB_ID=""
TARGET_JOB_SKIPFILE=""
TARGET_JOB_EXPECTED_STATUS=success
TARGET_JOB_MANDATORY=1
TARGET_JOB_DEP_RESOLVED=0
TARGET_JOB_ISRUNNING=""
TARGET_JOB_LASTEXEC_DATA=""
TARGET_JOB_LASTEXEC_STATUS=""
TARGET_JOB_LASTEXEC_TIME_END=""

DEP_WAIT_TIMEOUT=$(( 18 * 60 * 60 ))
DEP_WAIT_FORCE_EXEC=0
DEP_NODE_MODE="adapt"
DEP_JOB_NODE_REGEX=""
DEP_JOB_NODE_LST=""


STARTUP_DELAY_SEC=5
SLEEP_DURATION_SEC=60
TIME_CURRENT=$( date "+%s" )
TIME_FLOW_DAILY_START=-1        # heure de reference du plan => plage de j+0_15h00 à j+1_14h59
TIME_FLOW_DAILY_END=-1
REF_FLOW_DAILY_START="${RD_FLOW_DAILY_START:-15:00:00}"
REF_FLOW_DAILY_END="${RD_FLOW_DAILY_END:-14:59:59}"

REF_TMP_DIR=${RD_TMP_DIR:-/tmp/rundeck}
[ ! -d "${REF_TMP_DIR}" ] && REF_TMP_DIR=${RD_PLUGIN_TMPDIR}        # use the plugin tmp as a fallback

CURL_API_ROOT="${RD_JOB_SERVERURL%/}/api"
CURL_API_CMD="curl --silent --get --data-urlencode authtoken=${RD_TOKEN} ${CURL_API_ROOT}"

VAL_OK=";ok;success;succeeded;"
VAL_KO=";ko;error;failed;aborted;timedout;timeout"


# ----------------------------------------------------------------------------
# integrated help
function usageSyntax() {
    echo -e "
syntaxe    : $(basename $0) -project '<project name>' -group '<job group>' -job '<job name>' [-state <success | error>] 
                            [-force_launch] [-hardlink|-softlink] [-wait <duration in secs>] [-skip] 
                            [-flow_daily_start hh:mm:ss] [-flow_daily_end hh:mm:ss]
                            [-node_filtering <mode>] [-nodefilter_regex <regex>]

 -state    : expected status for the target job between [ success, error ] (default: success)
 -force_launch : force the execution when the waiting time period is reached
 -hardlink : (default) activate the dependency and wait until the targed job is started (if absent) and completed
 -softlink : activate the dependency only if the target job is already running, or completed (ok or ko)
 -wait     : maximum wait duration in seconds (default: $DEP_WAIT_TIMEOUT )
 -skip     : skip all checks and exit immediatly with a success state
 -flow_daily_start : start time of the execution flow (defaut : $REF_FLOW_DAILY_START )
 -flow_daily_end : end time of the execution flow (default : $REF_FLOW_DAILY_END )
 -node_filtering : one of those value [ adapt, global, regex ] to change the behavior when waiting between different nodes (default : adapt)
 -nodefilter_regex : specify the regex string if '-node_filtering' is set to 'regex'
 
Worth mentionning : 
 * $(basename $0) wait until the expiration delay is reached or the end of the execution flow as long as the targeted job isn't in the wanted state
 * if '-softlink' is set but the targeted job isn't already launched, there will be no wait.
 "
}

# -----------------------------------------------------------------------------
# stderr output
echoerr() { printf "%s\n" "$*" >&2; }

# check the Rundeck API access to all projects
rdProjects_VerifyAccess() {
    CURL_API_VERSION=11
    sTemp=$( ${CURL_API_CMD}/$CURL_API_VERSION/projects 2>&1)
    if [ $? -ne 0 ] || ! echo "$sTemp" | grep -i -q "projects count="; then echoerr "Error: cannot contact rundeck through the API nor access the project list"; echoerr "$sTemp"; exit 1; fi
}

# find a job GID from his project, group and job names
rdJob_GetIdFromName() {    
    CURL_API_VERSION=17
    sData=$( ${CURL_API_CMD}/${CURL_API_VERSION}/project/${TARGET_PROJECT_NAME}/jobs --data-urlencode groupPathExact="$TARGET_GROUP_NAME" --data-urlencode jobExactFilter="$TARGET_JOB_NAME"  2>&1 )
    if [ $? -ne 0 ] || ! echo "$sData"|grep -i -q "<jobs count="; then echoerr "Error: rdJob_GetIdFromName - bad API query"; echoerr "API message: $sData"; exit 1; fi
    if echo "$sData"|grep -i -q "<jobs count='0'"; then echoerr "Error: rdJob_GetIdFromName - target job '$TARGET_JOB_NAME' in group '$TARGET_GROUP_NAME' wasn't found"; exit 1; fi
    if ! echo "$sData"|grep -i -q "<jobs count='1'>"; then echoerr "Error: rdJob_GetIdFromName - more than a single job was returned "; exit 1; fi
        
    # on purpose to have a progress status message
    echoerr "Notice: JOB definition for '${TARGET_JOB_NAME}' found - extracting id ..."
        
    # expected format: <job id='a4997c82-86b9-42fb-8bfd-ff57fad90202' href='http://...' ...>
    echo "$sData" | grep -oP -i "job id='\K.*?(?=')"
}

# la commande liste la totalité des jobs en execution, sans filtrage possible
rdJob_IsRunning() {
    CURL_API_VERSION=14
    sData=$( ${CURL_API_CMD}/${CURL_API_VERSION}/project/${TARGET_PROJECT_NAME}/executions/running 2>&1  )
    if [ $? -ne 0 ]; then echoerr "Error: rdJob_IsRunning - bad API query"; echoerr "API message: $sData"; exit 1; fi
    
    # recherche de l'id du job cible
    sData=$( echo "$sData" | grep "$TARGET_JOB_ID" | head -1 )
    
    if [ -z "$sData" ]; then 
        echo 0 
    else 
        echo 1
    fi
}

rdJob_GetLastExecData() {
    CURL_API_VERSION=11
    sData=$( ${CURL_API_CMD}/${CURL_API_VERSION}/job/${TARGET_JOB_ID}/executions --data-urlencode max=1  2>&1 )    
    if [ $? -ne 0 ]; then echoerr "Error: rdJob_GetLastExecData - bad API query"; echoerr "API message: $sData"; exit 1; fi

    echo "$sData" | grep -v '^#'
    return 0    # grep renvoie rc=1 s'il n'y a pas de donnees
}

# structure : 
# rd-cli: 29 succeeded 2017-05-25T11:21:00+0200 2017-05-25T11:21:01+0200 http://<server>:<port>/project/<project name>/execution/show/9 job b8bae947-013a-4097-819f-86870b19662e <group>/<job name>
# api : ... <execution id='1116 ... status='succeeded' ...> ... <date-started unixtime='1512882600352'>2017-12-10T05:10:00Z</date-started> ... <date-ended unixtime='1512882604078'>2017-12-10T05:10:04Z</date-ended> ...
rdJob_GetLastExecValue() {
valueRet=""

    case $1 in
        -exec_id)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "execution id='\K.*?(?=')" )
            ;;
        
        -exec_url)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "<execution id=.* href='\K.*?(?=')" )
            ;;
        
        -time_start)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "date-started unixtime='\K.*?(?=')" )
            if [ ! -z "$valueRet" ]; then
                #cli only: valueRet=$( date -d "$valueRet" "+%s" )
                valueRet=$(( $valueRet / 1000 ))    # api unix time is in ms
            else
                valueRet=-1
            fi
            ;;

        -time_end)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "date-ended unixtime='\K.*?(?=')" )
            if [ ! -z "$valueRet" ]; then
                #cli only: valueRet=$( date -d "$valueRet" "+%s" )
                valueRet=$(( $valueRet / 1000 ))    # api unix time is in ms
            else
                valueRet=-1
            fi
            ;;
        
        -status|-state)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "<execution id=.* status='\K.*?(?=')" )
            if [ -z "$valueRet" ]; then valueRet="unknown"; fi
            if echo "$VAL_OK"|grep -q "$valueRet"; then valueRet="success"; fi
            if echo "$VAL_KO"|grep -q "$valueRet"; then valueRet="error"; fi
            ;;
        
        -nodes_success)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | tr '\n' '\a' | grep -oP -i "<successfulNodes>\K.*?(?=</successfulNodes>)" | tr '\a' '\n' )
            if [ ! -z "$valueRet" ]; then
                # suppression de '<node name=', puis des chars ' \ /  > et des espaces restants autour et lignes vides
                valueRet=$( echo "$valueRet" | sed "s/ *<node name=//;s#[\\'/>]##g;s/^ *//;s/ *$//;/^$/d" )
            fi
            ;;

        -nodes_fail)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | tr '\n' '\a' | grep -oP -i "<failedNodes>\K.*?(?=</failedNodes>)" | tr '\a' '\n' )
            if [ ! -z "$valueRet" ]; then
                # suppression de '<node name=', puis des chars ' \ /  > et des espaces restants autour et lignes vides
                valueRet=$( echo "$valueRet" | sed "s/ *<node name=//;s#[\\'/>]##g;s/^ *//;s/ *$//;/^$/d" )
            fi
            ;;
            
        *)
            echoerr "Error: rdJob_GetLastExecValue -  '$1' argument is unknown"
            exit 1
            ;;
        
    esac

    echo "$valueRet"
}
        
# -----------------------------------------------------------------------------
echo "RUNDECK DEPENDENCIES WAIT_JOB MODULE"
echo "Command line used : $0 $*"
echo ""

# parameters access validation
if [ $# -eq 0 ]; then usageSyntax; exit 1; fi

while [ $# -gt 0 ]; do 
    arg="$1"

    case $arg in
        -project)
            TARGET_PROJECT_NAME=$( echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;

        -group)
            TARGET_GROUP_NAME=$( echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;

        -job)
            TARGET_JOB_NAME=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;
        
        -state)
            TARGET_JOB_EXPECTED_STATUS=$( echo "$2" | tr '[:upper:]' '[:lower:]' )
            if ! echo "$VAL_OK;$VAL_KO" | grep -q "$TARGET_JOB_EXPECTED_STATUS"; then echoerr "Error: unexpected value '$2' for -state"; exit 1; fi
            shift
            ;;

        -hardlink)
            TARGET_JOB_MANDATORY=1
            ;;
            
        -softlink)
            TARGET_JOB_MANDATORY=0
            ;;

        -force_launch)
            DEP_WAIT_FORCE_EXEC=1
            ;;

        -wait|-max[wW]ait)
            DEP_WAIT_TIMEOUT=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            if ! [[ $DEP_WAIT_TIMEOUT =~ '^[0-9]+$' ]] ; then echoerr "Error: $arg $2 must be a number"; exit 1; fi
            shift
            ;;

        -startup_delay)
            STARTUP_DELAY_SEC=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;
            
        -bypass|-skip)
            DEPENDENCY_IGNORE=1
            ;;
        
        -sleep_duration)
            SLEEP_DURATION_SEC=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;

        -flow_daily_start)
            REF_FLOW_DAILY_START=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;

        -flow_daily_end)
            REF_FLOW_DAILY_END=$(echo "$2" | sed 's/^ *//;s/ *$//' )
            shift
            ;;

        -node_filtering)
            DEP_NODE_MODE=$2
            if ! echo "$DEP_NODE_MODE" | egrep -q -i "^(auto|adapt|global|regex)$"; then echoerr "Error: $arg $2 must be adapt, global or regex"; exit 1; fi
            shift
            ;;

        -nodefilter_regex)
            DEP_JOB_NODE_REGEX=$2
            shift
            ;;
            
        *)
            # rundeck can pass additionals spaces as args
            if [ ! -z "$( echo $1 | tr -d '[:space:]' )" ]; then
                echoerr "Error: '$1' argument is unknown"
                usageSyntax
                exit 1
            fi
            ;;
    esac
    
    #  next argument
    [ $# -gt 0 ] && shift
done

# Cmd line args: mandatory values 
if [ -z "$TARGET_PROJECT_NAME" ]; then echoerr "Error: the job's project name is required"; exit 1; fi
if [ -z "$TARGET_GROUP_NAME" ]; then echoerr "Error: the job's group name is required"; exit 1; fi
if [ -z "$TARGET_JOB_NAME" ]; then echoerr "Error: the job name is required"; exit 1; fi

# Cmd line args: node filters
if [ "$DEP_NODE_MODE" != "global" ]; then
    # a started job with an active filter will have RD_JOB_FILTER=name: srv1,srv2,...
    if [ ! -z "$RD_JOB_FILTER" ] && [[ ${RD_JOB_FILTER} == "name:"* ]]; then
        DEP_JOB_NODE_LST=$( echo "$RD_JOB_FILTER" | cut -d ':' -f2 | tr -d '[:blank:]' | tr ',' '|' )
    fi
fi

if [ ! -s "$PLUGIN_CONF_FILE" ] && [ -z "${RD_TOKEN}" ]; then echoerr "Error: couldn't find the API token in the $PLUGIN_CONF_FILE file or in the environment"; exit 1; fi
echo "Rundeck API Token found"

# API access validation
rdProjects_VerifyAccess || exit 1


# Workflow start and end time calculation -------------------------------------
dTodayLimit=$( date "+%Y-%m-%d ${REF_FLOW_DAILY_START}" )
dTodayLimit=$( date -d "${dTodayLimit}" "+%s" )

# Current workflow is still in the day-1 => today boundary
if [ $TIME_CURRENT -lt $dTodayLimit ]; then
    TIME_FLOW_DAILY_START=$( date --date='-1 day' "+%Y-%m-%d ${REF_FLOW_DAILY_START}" )
    TIME_FLOW_DAILY_START=$( date -d "${TIME_FLOW_DAILY_START}" "+%s" )
    
    TIME_FLOW_DAILY_END=$( date "+%Y-%m-%d ${REF_FLOW_DAILY_END}" )
    TIME_FLOW_DAILY_END=$( date -d "${TIME_FLOW_DAILY_END}" "+%s" )

# Current workflow was started today and will end at day+1
else
    TIME_FLOW_DAILY_START=$( date "+%Y-%m-%d ${REF_FLOW_DAILY_START}" )
    TIME_FLOW_DAILY_START=$( date -d "${TIME_FLOW_DAILY_START}" "+%s" )
    
    TIME_FLOW_DAILY_END=$( date --date='+1 day' "+%Y-%m-%d ${REF_FLOW_DAILY_END}" )
    TIME_FLOW_DAILY_END=$( date -d "${TIME_FLOW_DAILY_END}" "+%s" )
fi


# information banner ----------------------------------------------------------
echo "Current PID:$$"
echo "----------------------------------------------"
echo "FLOW START: $( date -d @$TIME_FLOW_DAILY_START --rfc-2822 )"
echo "FLOW END:   $( date -d @$TIME_FLOW_DAILY_END --rfc-2822 )"
echo "PROJECT:    $TARGET_PROJECT_NAME"
echo "JOB group:  $TARGET_GROUP_NAME"
echo "JOB name:   $TARGET_JOB_NAME"
echo "JOB wanted state : $TARGET_JOB_EXPECTED_STATUS"
echo "JOB dep type: $( if [ $TARGET_JOB_MANDATORY -eq 0 ]; then echo 'optional'; else echo 'required'; fi )"
echo "Node filter mode: ${DEP_NODE_MODE}"
[ "${DEP_NODE_MODE}" == "adapt" ] && [ ! -z "$DEP_JOB_NODE_LST" ] && echo "Filter list  : $DEP_JOB_NODE_LST"
[ "${DEP_NODE_MODE}" == "regex" ] && echo "Filter regex : $DEP_JOB_NODE_REGEX"
echo "----------------------------------------------"
echo ""


# check if the dependency was set to skip
if [ ! -z "$DEPENDENCY_IGNORE" ]; then
    echo "DEPENDENCY_IGNORE variable or -bypass parameter is set => the script will exit immediately => success"
    exit 0
fi

# Forced wait to allow other started jobs to set in
sleep ${STARTUP_DELAY_SEC}s


# Target job waiting sequence -------------------------------------------------
# lookup for the target job ID
TARGET_JOB_ID=$( rdJob_GetIdFromName ) || exit 1
TARGET_JOB_SKIPFILE=${REF_TMP_DIR}/deps_skip.$$.${TARGET_JOB_ID}

echo "JOB ID found: $TARGET_JOB_ID"
echo ""

echo "Waiting loop started (for $( date -u -d @${DEP_WAIT_TIMEOUT} +'%Hh%Mm%Ss' ))..."
echo "To exit this loop, run this shell command : sudo -u ${USER} touch ${TARGET_JOB_SKIPFILE}"
echo ""

# Wait loop
nCount=0
while [ $nCount -lt ${DEP_WAIT_TIMEOUT} ]; do    
    
    # search the manual skipfile presence
    if [ ! -z "$TARGET_JOB_SKIPFILE" ] && [ -f "$TARGET_JOB_SKIPFILE" ]; then
        echo "Skip file $TARGET_JOB_SKIPFILE present => success"
        rm "$TARGET_JOB_SKIPFILE"
        if [ $? -eq 0 ]; then 
            TARGET_JOB_DEP_RESOLVED=1
            break
        else
            echoerr "Error: the file $TARGET_JOB_SKIPFILE cannot be removed - continuing."
        fi
    fi
    
    # Job execution status
    TARGET_JOB_ISRUNNING=$( rdJob_IsRunning ) || exit 1
    
    if [ "$TARGET_JOB_ISRUNNING" == "0" ]; then
        # retrieve last execution information, if available
        TARGET_JOB_LASTEXEC_DATA=$( rdJob_GetLastExecData ) || exit 1
        if [ ! -z "$TARGET_JOB_LASTEXEC_DATA" ]; then
            TARGET_JOB_LASTEXEC_STATUS=$( rdJob_GetLastExecValue -status ) || exit 1
            TARGET_JOB_LASTEXEC_TIME_START=$( rdJob_GetLastExecValue -time_start ) || exit 1
            TARGET_JOB_LASTEXEC_TIME_END=$( rdJob_GetLastExecValue -time_end ) || exit 1
            TARGET_JOB_STATUS_NODES=""
            SEARCH_STATUS=""

            
            # validate the job was started in the today's workflow time range
            if [ $TARGET_JOB_LASTEXEC_TIME_START -ge $TIME_FLOW_DAILY_START ]; then

                case "$TARGET_JOB_EXPECTED_STATUS" in
                    success|ok)
                        SEARCH_STATUS="$VAL_OK"
                        TARGET_JOB_STATUS_NODES=$( rdJob_GetLastExecValue -nodes_success )     || exit 1
                        ;;
                    
                    error|failed|ko)
                        SEARCH_STATUS="$VAL_KO"
                        TARGET_JOB_STATUS_NODES=$( rdJob_GetLastExecValue -nodes_fail )        || exit 1
                        ;;
                esac

                # Compare the job completion status to the expected state
                if echo "$SEARCH_STATUS" | grep -q "$TARGET_JOB_LASTEXEC_STATUS"; then
                    
                    # behavior change depending of the node comparison mode
                    # adapt mode => will look for having the same node both jobs were executed on
                    if [ "$DEP_NODE_MODE" == "adapt" ] && [ ! -z "$DEP_JOB_NODE_LST" ]; then
                        if echo "$TARGET_JOB_STATUS_NODES" | egrep -i -q "^(${DEP_JOB_NODE_LST})$"; then
                            TARGET_JOB_DEP_RESOLVED=1
                            echo "Node filter list - node found in : "$TARGET_JOB_STATUS_NODES
                        fi
                    
                    # regex mode
                    elif  [ "$DEP_NODE_MODE" == "regex" ] && [ ! -z "$DEP_JOB_NODE_REGEX" ]; then
                        if echo "$TARGET_JOB_STATUS_NODES" | egrep -i -q "${DEP_JOB_NODE_REGEX}"; then
                            TARGET_JOB_DEP_RESOLVED=1
                            echo "Node filter regex - match found in : "$TARGET_JOB_STATUS_NODES
                        fi
                        
                    # global mode or no filter: any job in the expected state is valid, without regards for the execution node
                    else
                        TARGET_JOB_DEP_RESOLVED=1
                    fi


                    # exit if the deps resolution state is valid
                    if [ $TARGET_JOB_DEP_RESOLVED -eq 1 ]; then
                        echo "Valid execution found : $( date --iso-8601=seconds -d @$TARGET_JOB_LASTEXEC_TIME_END ) => status: $TARGET_JOB_LASTEXEC_STATUS"
                        break
                    fi
                fi

                
            # different workflow found
            else
                # exit if the dependency wasn't mandatory
                if [ $TARGET_JOB_MANDATORY -eq 0 ]; then
                    echo "No job execution for the current flow AND optional dependency => success"
                    TARGET_JOB_DEP_RESOLVED=1
                    break
                fi
            fi
            
        # no data
        else
            # job is missing and the dependency is not mandatory
            if [ $TARGET_JOB_MANDATORY -eq 0 ]; then
                echo "No job execution data found AND optional dependency => success"
                TARGET_JOB_DEP_RESOLVED=1
                break
            fi
        fi    
    fi
    
    nCount=$(( $nCount + $SLEEP_DURATION_SEC ))
    if [ $(( $nCount % 3600 )) -eq 0 ]; then echo "Still waiting after $(( $nCount / 3600 )) hour"; fi
    if [ $( date "+%s" ) -ge $TIME_FLOW_DAILY_END ]; then echo "Flow limit reached: $( date -d @${TIME_FLOW_DAILY_END} --iso-8601=seconds ) => timeout"; break; fi
    sleep ${SLEEP_DURATION_SEC}s
done

if [ $TARGET_JOB_DEP_RESOLVED -eq 0 ] && [ $DEP_WAIT_FORCE_EXEC -eq 1 ]; then 
    echo "Timeout reached AND forced execution active => success"
    TARGET_JOB_DEP_RESOLVED=1
fi

if [ $TARGET_JOB_DEP_RESOLVED -eq 0 ]; then 
    echo "Timeout reached and no valid job found with status: $TARGET_JOB_EXPECTED_STATUS => aborted"
    exit 1
fi

exit 0
