#!/bin/bash
# -------------------------------------------------------------------------------------------
# Script for waiting for another job, allowing to create a dependency between them.
# A token with read access to the Rundeck API is required
#
# integrated self-help
# -------------------------------------------------------------------------------------------
# 2017/07/09    AHZ creation


# External variables
# RD_JOB_SERVERURL=<generated by rundeck>
# DEPENDENCY_IGNORE=<optional, empty or "anything non blank" >
# RD_FLOW_DAILY_START=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg>
# RD_FLOW_DAILY_END=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg >
# RD_TMP_DIR=<optional or path to the Rundeck tmp dir>
# RD_JOB_FILTER=<generated by rundeck when a job is ran on specific nodes>

# External file
PLUGIN_CONF_FILE=/etc/rundeck/plugin-dependencies.conf
[ -s $PLUGIN_CONF_FILE ] && export RD_TOKEN=$( cat $PLUGIN_CONF_FILE 2>&1| tr -d '\n' )


# Include file
PLUGIN_INCLUDE_FILE=$( dirname $0 )/dep_wait_common.include


# default values
TARGET_PROJECT_NAME=""
TARGET_GROUP_NAME=""
TARGET_JOB_NAME=""
TARGET_JOB_ID=""
TIME_FLOW_JOB_SKIPFILE=""
TARGET_JOB_EXPECTED_STATUS=success
TARGET_JOB_MANDATORY=1
TARGET_JOB_DEP_RESOLVED=0
TARGET_JOB_ISRUNNING=""
TARGET_JOB_ISINFLOW=0
TARGET_JOB_LASTEXEC_DATA=""
TARGET_JOB_LASTEXEC_STATUS=""
TARGET_JOB_LASTEXEC_TIME_END=""


# ----------------------------------------------------------------------------
# integrated help
function usageSyntax() {
    echo -e "
syntaxe    : $(basename $0) -project '<project name>' -group '<job group>' -job '<job name>' [-state <success | error>] 
                            [-force_launch] [-hardlink|-softlink] [-wait <duration in secs>] [-skip] 
                            [-flow_daily_start hh:mm:ss] [-flow_daily_end hh:mm:ss]
                            [-node_filtering <mode>] [-nodefilter_regex <regex>]

 -state    : expected status for the target job between [ success, error ] (default: success)
 -force_launch : force the execution when the waiting time period is reached
 -hardlink : (default) activate the dependency and wait until the targed job is started (if absent) and completed
 -softlink : activate the dependency only if the target job is already running, or completed (ok or ko)
 -wait     : maximum wait duration in seconds (default: $DEP_WAIT_TIMEOUT )
 -skip     : skip all checks and exit immediatly with a success state
 -flow_daily_start : start time of the execution flow (defaut : $REF_FLOW_DAILY_START )
 -flow_daily_end : end time of the execution flow (default : $REF_FLOW_DAILY_END )
 -node_filtering : one of those value [ adapt, global, regex ] to change the behavior when waiting between different nodes (default : adapt)
 -nodefilter_regex : specify the regex string if '-node_filtering' is set to 'regex'
 
Worth mentionning : 
 * $(basename $0) wait until the expiration delay is reached or the end of the execution flow as long as the targeted job isn't in the wanted state
 * if '-softlink' is set but the targeted job isn't already launched, there will be no wait.
 "
}


# -----------------------------------------------------------------------------
# curl command
# args: anything from: curl https://rundeck/api/<arg1> <arg2> <arg3> ...
_curlCmd() {
    CURL_API_ROOT="${RD_JOB_SERVERURL%/}/api"
    # curl v7.55.0+ is required for using "@-"
    echo "X-Rundeck-Auth-Token: $RD_TOKEN" | curl --retry 3 --user-agent "dependencies-wait_job/curl" --get -H @- --silent ${CURL_API_ROOT}/"$@"  2>&1
}
# ref: https://docs.rundeck.com/docs/api/rundeck-api-versions.html
CURL_API_VERSION_MIN=14

# check the Rundeck API access to all projects
# input: n/a
# output: error code
rdProjects_VerifyAccess() {
    sData=$( _curlCmd ${CURL_API_VERSION_MIN}/projects )
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'  ||  ! echo "$sData" | grep -i -q "projects count="; then echoerr "Error: cannot contact rundeck through the API nor access the project list"; echoerr "$sData"; exit 1; fi
}


# get the projects list
# input: n/a
# output: list of projects names
rdProjects_getList() {
    sData=$( _curlCmd ${CURL_API_VERSION_MIN}/projects )
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'; then echoerr "Error: projects list - bad API query"; echoerr "$sData"; exit 1; fi

    sData=$( echo "$sData" | grep -Po "<name>\K.*?(?=</name>)" )

    echo "$sData" | grep -v '^#'
    return 0    # grep will return rc=1 if there is no data
}


# get the job list from a project
# input: "project name"
# output: list of jobs names
rdProject_getJobList() {
    TARGET_PROJECT=$1
    
    CURL_API_VERSION=17
    sData=$( _curlCmd ${CURL_API_VERSION}/project/${TARGET_PROJECT}/jobs )
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'; then echoerr "Error: job list - bad API query"; echoerr "$sData"; exit 1; fi

    # tranform the xml data in single line, then add \n between job blocs
    echo echo "$sData" | tr '\n' ' ' | sed 's#>[ \t]*<#><#g' | sed 's#</job><job#</job>\n<job#g'
}


# find a job GID from his project, group and job names
# input: TARGET_PROJECT_NAME, TARGET_GROUP_NAME, TARGET_JOB_NAME
# output: job id
rdJob_GetIdFromName() {    
    CURL_API_VERSION=17
    sData=$( _curlCmd ${CURL_API_VERSION}/project/${TARGET_PROJECT_NAME}/jobs --data-urlencode groupPathExact="$TARGET_GROUP_NAME" --data-urlencode jobExactFilter="$TARGET_JOB_NAME"  )
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'  ||  ! echo "$sData"|grep -i -q "<jobs count="; then echoerr "Error: rdJob_GetIdFromName - bad API query"; echoerr "API message: $sData"; exit 1; fi
    if echo "$sData"|grep -i -q "<jobs count='0'"; then echoerr "Error: rdJob_GetIdFromName - target job '$TARGET_JOB_NAME' in group '$TARGET_GROUP_NAME' wasn't found"; exit 1; fi
    if ! echo "$sData"|grep -i -q "<jobs count='1'>"; then echoerr "Error: rdJob_GetIdFromName - more than a single job was returned "; exit 1; fi
        
    # on purpose to have a progress status message
    echoerr "Notice: JOB definition for '${TARGET_JOB_NAME}' found - extracting id ..."
        
    # expected format: <job id='a4997c82-86b9-42fb-8bfd-ff57fad90202' href='http://...' ...>
    echo "$sData" | grep -oP -i "job id='\K.*?(?=')"
}

# the execution/running api list all currently running job, without any filter option
# input: TARGET_PROJECT_NAME, TARGET_JOB_ID
# output: 0 or 1 depending if the job is running or not 
rdJob_IsRunning() {
    sData=$( _curlCmd ${CURL_API_VERSION_MIN}/project/${TARGET_PROJECT_NAME}/executions/running  )
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'; then echoerr "Error: rdJob_IsRunning - bad API query"; echoerr "API message: $sData"; exit 1; fi
    
    # look for the requested job id
    sData=$( echo "$sData" | grep "$TARGET_JOB_ID" | head -1 )
    
    if [ -z "$sData" ]; then 
        echo 0 
    else 
        echo 1
    fi
}


# find the last job execution data
# input: TARGET_JOB_ID
# output: the latest execution data
rdJob_GetLastExecData() {
    sData=$( _curlCmd ${CURL_API_VERSION_MIN}/job/${TARGET_JOB_ID}/executions --data-urlencode max=1 )    
    if [ $? -ne 0 ]  ||  echo "$sData" |grep -i 'error"*:true'; then echoerr "Error: rdJob_GetLastExecData - bad API query"; echoerr "API message: $sData"; exit 1; fi

    echo "$sData" | grep -v '^#'
    return 0    # grep will return rc=1 if there is no data
}


# selected value frop a job execution data
# input: "-<data type to retrieve>", TARGET_JOB_LASTEXEC_DATA
# output: "the value for the specific data type"
#
# structure : 
# rd-cli: 29 succeeded 2017-05-25T11:21:00+0200 2017-05-25T11:21:01+0200 http://<server>:<port>/project/<project name>/execution/show/9 job b8bae947-013a-4097-819f-86870b19662e <group>/<job name>
# api : ... <execution id='1116 ... status='succeeded' ...> ... <date-started unixtime='1512882600352'>2017-12-10T05:10:00Z</date-started> ... <date-ended unixtime='1512882604078'>2017-12-10T05:10:04Z</date-ended> ...
rdJob_GetLastExecValue() {
valueRet=""

    case $1 in
        -exec_id)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "execution id='\K.*?(?=')" )
            ;;
        
        -exec_url)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "<execution id=.* href='\K.*?(?=')" )
            ;;
        
        -time_start)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "date-started unixtime='\K.*?(?=')" )
            if [ ! -z "$valueRet" ]; then
                #cli only: valueRet=$( date -d "$valueRet" "+%s" )
                valueRet=$(( $valueRet / 1000 ))    # api unix time is in ms
            else
                valueRet=-1
            fi
            ;;

        -time_end)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "date-ended unixtime='\K.*?(?=')" )
            if [ ! -z "$valueRet" ]; then
                #cli only: valueRet=$( date -d "$valueRet" "+%s" )
                valueRet=$(( $valueRet / 1000 ))    # api unix time is in ms
            else
                valueRet=-1
            fi
            ;;
        
        -status|-state)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | grep -oP -i "<execution id=.* status='\K.*?(?=')" )
            if [ -z "$valueRet" ]; then valueRet="unknown"; fi
            if echo "$VAL_OK"|grep -q "$valueRet"; then valueRet="success"; fi
            if echo "$VAL_KO"|grep -q "$valueRet"; then valueRet="error"; fi
            ;;
        
        -nodes_success)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | tr '\n' '\a' | grep -oP -i "<successfulNodes>\K.*?(?=</successfulNodes>)" | tr '\a' '\n' )
            if [ ! -z "$valueRet" ]; then
                # remove '<node name=' then the chars  ' \ /  > then whitespaces around then empty lines
                valueRet=$( echo "$valueRet" | sed "s/ *<node name=//;s#[\\'/>]##g;s/^ *//;s/ *$//;/^$/d" )
            fi
            ;;

        -nodes_fail)
            valueRet=$( echo "$TARGET_JOB_LASTEXEC_DATA" | tr '\n' '\a' | grep -oP -i "<failedNodes>\K.*?(?=</failedNodes>)" | tr '\a' '\n' )
            if [ ! -z "$valueRet" ]; then
                # remove '<node name=' then the chars  ' \ /  > then whitespaces around then empty lines
                valueRet=$( echo "$valueRet" | sed "s/ *<node name=//;s#[\\'/>]##g;s/^ *//;s/ *$//;/^$/d" )
            fi
            ;;
            
        *)
            echoerr "Error: rdJob_GetLastExecValue -  '$1' argument is unknown"
            exit 1
            ;;
        
    esac

    echo "$valueRet"
}
        
# -----------------------------------------------------------------------------
echo "RUNDECK DEPENDENCIES WAIT_JOB MODULE"
echo "Command line used : $0 $*"
echo ""


# load the include file
source ${PLUGIN_INCLUDE_FILE}
if [ $? -ne 0 ]; then echo "Error: the function file '$PLUGIN_INCLUDE_FILE' was not found"; exit 1; fi


# curl presence verification
if ! command -v curl >/dev/null 2>&1; then echoerr "Error: the command 'curl' was not found in the path"; exit 1; fi

# parameters access validation
if [ $# -eq 0 ]; then usageSyntax; exit 1; fi

while [ $# -gt 0 ]; do 
    arg="$1"

    case $arg in
        -project)
            TARGET_PROJECT_NAME=$( trim "$2" )
            shift
            ;;

        -group)
            TARGET_GROUP_NAME=$( trim "$2" )
            shift
            ;;

        -job)
            TARGET_JOB_NAME=$( trim "$2" )
            shift
            ;;
        
        -state)
            TARGET_JOB_EXPECTED_STATUS=$( echo "$2" | tr '[:upper:]' '[:lower:]' )
            if ! echo "$VAL_OK;$VAL_KO" | grep -q "$TARGET_JOB_EXPECTED_STATUS"; then echoerr "Error: unexpected value '$2' for -state"; exit 1; fi
            shift
            ;;

        -hardlink)
            TARGET_JOB_MANDATORY=1
            ;;
            
        -softlink)
            TARGET_JOB_MANDATORY=0
            ;;

        -force_launch)
            DEP_WAIT_FORCE_EXEC=1
            ;;

        -wait|-max[wW]ait)
            DEP_WAIT_TIMEOUT=$( trim "$2" )
            if ! [[ $DEP_WAIT_TIMEOUT =~ '^[0-9]+$' ]] ; then echoerr "Error: $arg $2 must be a number"; exit 1; fi
            shift
            ;;

        -startup_delay)
            STARTUP_DELAY_SEC=$( trim "$2" )
            shift
            ;;
            
        -bypass|-skip)
            DEPENDENCY_IGNORE=1
            ;;
        
        -sleep_duration)
            SLEEP_DURATION_SEC=$( trim "$2" )
            shift
            ;;

        -flow_daily_start)
            REF_FLOW_DAILY_START=$( trim "$2" )
            shift
            ;;

        -flow_daily_end)
            REF_FLOW_DAILY_END=$( trim "$2" )
            shift
            ;;

        -node_filtering)
            DEP_NODE_MODE=$2
            if ! echo "$DEP_NODE_MODE" | egrep -q -i "^(auto|adapt|global|regex)$"; then echoerr "Error: $arg $2 must be adapt, global or regex"; exit 1; fi
            shift
            ;;

        -nodefilter_regex)
            DEP_JOB_NODE_REGEX=$2
            shift
            ;;
            
        *)
            # rundeck can pass additionals spaces as args
            # rundeck issue #8509 - sending the plugin.yaml variable name as-is instead of evaluated when empty
            if [ ! -z "${1// /}" ] && [ "$1" != '${option.DEPENDENCY_EXTRA_PARAMS}' ]; then
                echoerr "Error: '$1' argument is unknown"
                usageSyntax
                exit 1
            fi
            ;;
    esac
    
    #  argument suivant
    [ $# -gt 0 ] && shift
done

# validate received and mandatory values
if [ -z "$TARGET_PROJECT_NAME" ]; then echoerr "Error: the job's project name is required"; exit 1; fi
if [ -z "$TARGET_GROUP_NAME" ]; then echoerr "Error: the job's group name is required"; exit 1; fi
if [ -z "$TARGET_JOB_NAME" ]; then echoerr "Error: the job name is required"; exit 1; fi

if [ "$DEP_NODE_MODE" != "global" ]; then
    # a started job with an active filter will have RD_JOB_FILTER=name: srv1,srv2,...
    if [ ! -z "$RD_JOB_FILTER" ] && [[ ${RD_JOB_FILTER} == "name:"* ]]; then
        DEP_JOB_NODE_LST=$( echo "$RD_JOB_FILTER" | cut -d ':' -f2 | tr -d '[:blank:]' | tr ',' '|' )
    fi
fi

if [ ! -s "$PLUGIN_CONF_FILE" ] && [ -z "${RD_TOKEN}" ]; then echoerr "Error: couldn't find the API token in the $PLUGIN_CONF_FILE file or in the environment"; exit 1; fi
echo "Rundeck API Token found"

# API access validation
rdProjects_VerifyAccess || exit 1


# Workflow start and end time -------------------------------------
TIME_FLOW_DAILY_START=$( timeFlow_dailyStart )
TIME_FLOW_DAILY_END=$( timeFlow_dailyEnd )
TIME_FLOW_JOB_SKIPFILE=${REF_TMP_DIR}/deps_job_skip.$$.${RD_JOB_ID}


# information banner ----------------------------------------------------------
echo "Current PID:  $$"
echo "Started at:   $( date --iso-8601=seconds )"
echo "----------------------------------------------"
echo "FLOW START:   $( date -d @$TIME_FLOW_DAILY_START --rfc-2822 )"
echo "FLOW END:     $( date -d @$TIME_FLOW_DAILY_END --rfc-2822 )"
echo "PROJECT:      $TARGET_PROJECT_NAME"
echo "JOB group:    $TARGET_GROUP_NAME"
echo "JOB name:     $TARGET_JOB_NAME"
echo "JOB wanted state : $TARGET_JOB_EXPECTED_STATUS"
echo "JOB dep type: $( if [ $TARGET_JOB_MANDATORY -eq 0 ]; then echo 'optional'; else echo 'required'; fi )"
echo "Node filter mode: ${DEP_NODE_MODE}"
[ "${DEP_NODE_MODE}" == "adapt" ] && [ ! -z "$DEP_JOB_NODE_LST" ] && echo "Filter list:  $DEP_JOB_NODE_LST"
[ "${DEP_NODE_MODE}" == "regex" ] && echo "Filter regex: $DEP_JOB_NODE_REGEX"
echo "----------------------------------------------"
echo ""


# check if the dependency was set to skip
if [ ! -z "$DEPENDENCY_IGNORE" ]; then
    echo "DEPENDENCY_IGNORE variable or -skip parameter is set => the script will exit immediately => success"
    exit 0
fi

# Forced wait to allow other started jobs to set in
sleep ${STARTUP_DELAY_SEC}s


# Target job waiting sequence -------------------------------------------------

# lookup for the target job ID
TARGET_JOB_ID=$( rdJob_GetIdFromName ) || exit 1
echo "JOB ID found: $TARGET_JOB_ID"
echo ""


# Wait loop
timeFlow_startWaitingMsg
nCount=0
while [ $nCount -lt ${DEP_WAIT_TIMEOUT} ]; do    
    
    # search for the manually created skipfile
    if timeFlow_skipFileExists "$TIME_FLOW_JOB_SKIPFILE"; then TARGET_JOB_DEP_RESOLVED=1; break; fi
    
    # Job execution status
    TARGET_JOB_ISRUNNING=$( rdJob_IsRunning ) || exit 1
    
    if [ "$TARGET_JOB_ISRUNNING" == "0" ]; then
        # retrieve last execution information, if available
        TARGET_JOB_LASTEXEC_DATA=$( rdJob_GetLastExecData ) || exit 1
        if [ ! -z "$TARGET_JOB_LASTEXEC_DATA" ]; then
            TARGET_JOB_LASTEXEC_STATUS=$( rdJob_GetLastExecValue -status ) || exit 1
            TARGET_JOB_LASTEXEC_TIME_START=$( rdJob_GetLastExecValue -time_start ) || exit 1
            TARGET_JOB_LASTEXEC_TIME_END=$( rdJob_GetLastExecValue -time_end ) || exit 1
            TARGET_JOB_STATUS_NODES=""
            SEARCH_STATUS=""

            
            # validate the job was started in the today's workflow time range
            if [ $TARGET_JOB_LASTEXEC_TIME_START -ge $TIME_FLOW_DAILY_START ]; then
                TARGET_JOB_ISINFLOW=1

                case "$TARGET_JOB_EXPECTED_STATUS" in
                    success|ok)
                        SEARCH_STATUS="$VAL_OK"
                        TARGET_JOB_STATUS_NODES=$( rdJob_GetLastExecValue -nodes_success )     || exit 1
                        ;;
                    
                    error|failed|ko)
                        SEARCH_STATUS="$VAL_KO"
                        TARGET_JOB_STATUS_NODES=$( rdJob_GetLastExecValue -nodes_fail )        || exit 1
                        ;;
                esac

                # Compare the job completion status to the expected state
                if echo "$SEARCH_STATUS" | grep -q "$TARGET_JOB_LASTEXEC_STATUS"; then
                    
                    # behavior change depending of the node comparison mode
                    # adapt mode => will look for having the same node both jobs were executed on
                    if [ "$DEP_NODE_MODE" == "adapt" ] && [ ! -z "$DEP_JOB_NODE_LST" ]; then
                        if echo "$TARGET_JOB_STATUS_NODES" | egrep -i -q "^(${DEP_JOB_NODE_LST})$"; then
                            TARGET_JOB_DEP_RESOLVED=1
                            echo "Node filter list - node found in : "$TARGET_JOB_STATUS_NODES
                        fi

                    # regex mode
                    elif  [ "$DEP_NODE_MODE" == "regex" ] && [ ! -z "$DEP_JOB_NODE_REGEX" ]; then
                        if echo "$TARGET_JOB_STATUS_NODES" | egrep -i -q "${DEP_JOB_NODE_REGEX}"; then
                            TARGET_JOB_DEP_RESOLVED=1
                            echo "Node filter regex - match found in : "$TARGET_JOB_STATUS_NODES
                        fi
                        
                    # global mode or no filter: any job in the expected state is valid, without regards for the execution node
                    else
                        TARGET_JOB_DEP_RESOLVED=1
                    fi


                    # exit if the deps resolution state is valid
                    if [ $TARGET_JOB_DEP_RESOLVED -eq 1 ]; then
                        echo "Valid execution found : $( date --iso-8601=seconds -d @$TARGET_JOB_LASTEXEC_TIME_END ) => status: $TARGET_JOB_LASTEXEC_STATUS"
                        break
                    fi
                fi

            # different workflow found but no job existing in the current flow
            else
                # exit if the dependency wasn't mandatory
                if [ $TARGET_JOB_MANDATORY -eq 0 ]; then
                    if [ $TARGET_JOB_ISINFLOW -eq 1 ]; then
                        echo "A job execution was found in the current flow but seems now to have been removed AND optional dependency => success"
                    else
                        echo "No job execution for the current flow AND optional dependency => success"
                    fi
                    TARGET_JOB_DEP_RESOLVED=1
                    break
                fi
            fi

        # no data
        else
            # job is missing and the dependency is not mandatory
            if [ $TARGET_JOB_MANDATORY -eq 0 ]; then
                echo "No job execution data found AND optional dependency => success"
                TARGET_JOB_DEP_RESOLVED=1
                break
            fi
        fi    
    fi
    
    nCount=$(( $nCount + $SLEEP_DURATION_SEC ))
    timeFlow_stillWaiting $nCount
    if ! timeFlow_limitReach $TIME_FLOW_DAILY_END; then break; fi
    sleep ${SLEEP_DURATION_SEC}s
done

if [ $TARGET_JOB_DEP_RESOLVED -eq 0 ] && [ $DEP_WAIT_FORCE_EXEC -eq 1 ]; then 
    echo "Timeout reached AND forced execution active => success"
    TARGET_JOB_DEP_RESOLVED=1
fi

if [ $TARGET_JOB_DEP_RESOLVED -eq 0 ]; then 
    echo "Timeout reached and no valid job found with status: $TARGET_JOB_EXPECTED_STATUS => aborted"
    exit 1
fi

exit 0
