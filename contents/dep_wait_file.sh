#!/bin/bash
# -------------------------------------------------------------------------------------------
# script for waiting for a file, allowing to create a dependency uppon its arrival
# A token with read access to the Rundeck API is required
#
# integrated self-help
# -------------------------------------------------------------------------------------------
# 2018/05/13	AHZ creation


# External variables
# RD_JOB_SERVERURL=<generated by rundeck>
# DEPENDENCY_IGNORE=<optional, empty or "anything non blank" >
# RD_FLOW_DAILY_START=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg>
# RD_FLOW_DAILY_END=<optional or "hh:mm:ss" as global, can also be set as a cmd line arg >
# RD_TMP_DIR=<optional or path to the Rundeck tmp dir>
# RD_JOB_FILTER=<generated by rundeck when a job is ran on specific nodes>



# Include file
PLUGIN_INCLUDE_FILE=$( dirname `readlink -f $0` )/dep_wait_common.include


# default values
TARGET_HOST="local"
TARGET_DIRECTORY=""
TARGET_FILENAME=""
TARGET_FLAG_EXT=".flag"
TARGET_FLAG_FILENAME=""
TARGET_FLAG_USE=0
TARGET_FLAG_TYPE=auto           # possible values : auto, md5, sha
TARGET_FILE_RECEIVED=0

# hash commands related to the length of each hash
declare -a HASH_CMD
HASH_CMD[5]="sum -r"          # BSD algorithm
HASH_CMD[9]=cksum             # CRC
HASH_CMD[32]=md5sum
HASH_CMD[40]=sha1sum
HASH_CMD[64]=sha256sum
HASH_CMD[96]=sha384sum
HASH_CMD[128]=sha512sum

SSH_CMD=""
SSH_CMD_BASE="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=QUIET"
SSH_TEXT_INFO=""


# ----------------------------------------------------------------------------
# syntaxe d'utilisation
function usageSyntax() {
	echo -e "
syntaxe    : $(basename $0) -directory 'path' -file 'file.ext' [-flag|-noflag] [-flag_ext 'extension'] 
                            [-host user@host] [-force_launch] [-wait <duration in secs>] [-skip] 

 -(no)flag : activate or disable the use of a flag file to look for when the target file transfert is complete
 -host     : allow to specify a remove host to check for the file presence
 -force_launch : force the execution when the waiting time period is reached
 -wait     : maximum wait duration in seconds (default: $DEP_WAIT_TIMEOUT )
 -skip     : (skip all checks and exit immediatly with a success state
 
Worth mentionning : 
 * $(basename $0) wait until the expiration delay is reached or the end of the execution flow as long as the targeted file isn't present
 "
}


# ----------------------------------------------------------------------------
echo "RUNDECK DEPENDENCIES WAIT_FILE MODULE"
echo "Command line used : $0 $*"
echo ""


# load the include file
source ${PLUGIN_INCLUDE_FILE}
if [ $? -ne 0 ]; then echo "Error: the function file '$PLUGIN_INCLUDE_FILE' was not found"; exit 1; fi


# parameters access validation
if [ $# -eq 0 ]; then usageSyntax; exit 1; fi

while [ $# -gt 0 ]; do 
    arg="$1"

    case $arg in
        -host|-target_host)
            TARGET_HOST=$( trim "$2" )
            shift
            ;;

        -directory)
            TARGET_DIRECTORY=$( trim "$2" )
            shift
            ;;

        -file|-filename)
            TARGET_FILENAME=$( trim "$2" )
            shift
            ;;

        -flag_ext)
            TARGET_FLAG_EXT=$( trim "$2" )
            shift
            ;;

        -flag)
            TARGET_FLAG_USE=1
            ;;
        
        -noflag)
            TARGET_FLAG_USE=0
            ;;
            
        -force_launch)
            TARGET_WAIT_FORCE_EXEC=1
            ;;

        -wait|-max[wW]ait)
            DEP_WAIT_TIMEOUT=$( trim "$2" )
            if ! [[ $DEP_WAIT_TIMEOUT =~ '^[0-9]+$' ]] ; then echoerr "Error: $arg $2 must be a number"; exit 1; fi
            shift
            ;;

        -startup_delay)
            STARTUP_DELAY_SEC=$( trim "$2" )
            shift
            ;;

        -bypass|-skip)
            DEPENDENCY_IGNORE=1
            ;;

        -sleep_duration)
            SLEEP_DURATION_SEC=$( trim "$2" )
            shift
            ;;

        -flow_daily_start)
            REF_FLOW_DAILY_START=$( trim "$2" )
            shift
            ;;

        -flow_daily_end)
            REF_FLOW_DAILY_END=$( trim "$2" )
            shift
            ;;

        *)
            # rundeck can pass additionals spaces as args
            # rundeck issue #8509 - sending the plugin.yaml variable name as-is instead of evaluated when empty
            if [ ! -z "${1// /}" ] && [ "$1" != '${option.DEPENDENCY_EXTRA_PARAMS}' ]; then
                echoerr "Error: '$1' argument is unknown"
                usageSyntax
                exit 1
            fi
            ;;
    esac
    
    #  argument suivant
    [ $# -gt 0 ] && shift
done

# validate received values
if [ -z "$TARGET_DIRECTORY" ] || [ -z "$TARGET_FILENAME" ]; then echoerr "Error: the directory and name of the target file are required"; exit 1; fi

if [ $TARGET_FLAG_USE -eq 1 ] && [ -z "$TARGET_FLAG_EXT" ]; then echoerr "Error: the flag extension is empty"; exit 1; fi
TARGET_FLAG_FILENAME="${TARGET_FILENAME}${TARGET_FLAG_EXT}"

if [ ! -z "$TARGET_HOST" ] && [ "$TARGET_HOST" != "local" ]; then 
    SSH_CMD="$SSH_CMD_BASE $TARGET_HOST "
    SSH_TEXT_INFO=" on $TARGET_HOST "
fi


# Workflow start and end time -------------------------------------
TIME_FLOW_DAILY_START=$( timeFlow_dailyStart )
TIME_FLOW_DAILY_END=$( timeFlow_dailyEnd )
TIME_FLOW_JOB_SKIPFILE=${REF_TMP_DIR}/deps_file_skip.$$.${RD_JOB_ID}


# information banner
echo "Current PID:$$"
echo "----------------------------------------------"
echo "Location:   $TARGET_HOST"
echo "Directory:  $TARGET_DIRECTORY"
echo "File:       $TARGET_FILENAME"
echo "Flag file:  $( if [ $TARGET_FLAG_USE -eq 0 ]; then echo 'n/a'; else echo $TARGET_FLAG_FILENAME; fi )"
echo "----------------------------------------------"
echo ""


# check if the dependency was set to skip
if [ ! -z "$DEPENDENCY_IGNORE" ]; then
    echo "DEPENDENCY_IGNORE variable or -skip parameter is set => the script will exit immediately => success"
    exit 0
fi

# Forced wait to allow other started jobs to set in
sleep ${STARTUP_DELAY_SEC}s


# Target file waiting sequence -------------------------------------------------

# check the target directory presence - not blocking
if [ ! -d "$TARGET_DIRECTORY" ] && [ ! -h "$TARGET_DIRECTORY" ]; then 
    echo "NOTICE: the target directory was not found or is not created yet $SSH_TEXT_INFO: $TARGET_DIRECTORY"
else
    echo "Directory found $SSH_TEXT_INFO: $TARGET_DIRECTORY"
fi
echo ""


# Wait loop
timeFlow_startWaitingMsg
nCount=0
while [ $nCount -lt ${DEP_WAIT_TIMEOUT} ]; do

    # search for the manually created skipfile
    if timeFlow_skipFileExists "$TIME_FLOW_JOB_SKIPFILE"; then TARGET_FILE_RECEIVED=1; break; fi

    # dir/file presence test
    sFileCheck=$( $SSH_CMD find "$TARGET_DIRECTORY" -maxdepth 1 -name "$TARGET_FILENAME" -type f 2>/dev/null )
    if [ ! -z "$sFileCheck" ]; then 
    
        # flag is not used  => exit
        if [ $TARGET_FLAG_USE -eq 0 ]; then
            echo "Target file found $SSH_TEXT_INFO: $TARGET_DIRECTORY/$TARGET_FILENAME => success"
            TARGET_FILE_RECEIVED=1
            break
        
        # flag is requested, wait for it
        else
            echo "Target file found $SSH_TEXT_INFO: $TARGET_DIRECTORY/$TARGET_FILENAME - looking for flag file ..."
            sFlagCheck=$( $SSH_CMD find "$TARGET_DIRECTORY" -maxdepth 1 -name "$TARGET_FLAG_FILENAME" -type f 2>/dev/null )
            if [ ! -z "$sFileCheck" ]; then
                echo "Target flag found $SSH_TEXT_INFO: $TARGET_DIRECTORY/$TARGET_FLAG_FILENAME => success"
                TARGET_FILE_RECEIVED=1
                break
            fi
        fi
    fi

    nCount=$(( $nCount + $SLEEP_DURATION_SEC ))
    timeFlow_stillWaiting $nCount
    if ! timeFlow_limitReach $TIME_FLOW_DAILY_END; then break; fi
    sleep ${SLEEP_DURATION_SEC}s
done


# read the flag file content and act accordingly
if [ $TARGET_FILE_RECEIVED -eq 1 ] && \
   [ $TARGET_FLAG_USE -eq 1 ] && \
   [ -s "$TARGET_DIRECTORY/$TARGET_FLAG_FILENAME" ]
   then
    echo ""
    sFlagContent=$( $SSH_CMD cat "$TARGET_DIRECTORY/$TARGET_FLAG_FILENAME" )
    if [ $? -ne 0 ]; then echoerr "Error: couldn't read the file $TARGET_DIRECTORY/$TARGET_FLAG_FILENAME $SSH_TEXT_INFO"; exit 1; fi
    
    # clean up the content from unwanted spaces and comments
    # a hash file can contain both the hash and the filename, separated by a blank
    sFlagContent=$( echo "$sFlagContent" | sed 's/^ *//;s/ *$//;s/^#.*//' | cut -d ' ' -f1)
    nFlagLen=${#sFlagContent}

    if [ $nFlagLen -le 2 ]; then
        echo "NOTICE: received flag has no content while its size is not 0."

    else
        echo "Processing hash found in $TARGET_FLAG_FILENAME ..."
        sFlagBin=${HASH_CMD[${nFlagLen}]}
        if [ "$sFlagBin" != "" ]; then
            echo "Related binary detected : $sFlagBin"
            sFileHash=$( $SSH_CMD $sFlagBin "$TARGET_DIRECTORY/$TARGET_FILENAME" 2>&1 )
            if [ $? -ne 0 ]; then echoerr "Error: could not validate the file $TARGET_DIRECTORY/$TARGET_FILENAME $SSH_TEXT_INFO"; echo "$sFileHash"; exit 1; fi
            
            sFileHash=$( echo "$sFileHash" | cut -d ' ' -f1 )
            if [ "$sFileHash" != "$sFlagContent" ]; then 
                echoerr "Error: the hash in the flag file doesn't match with the received file"
                echoerr "  calculated hash with $sFlagBin : $sFileHash"
                echoerr "  hash in the flag file : $sFlagContent"
                exit 1
            fi
            echo "Target file hash is valid: $sFlagContent"
            
        else
            echoerr "Warning: no command available for a $nFlagLen characters hash $SSH_TEXT_INFO"
        fi
    fi
fi

if [ $TARGET_FILE_RECEIVED -eq 0 ] && [ $TARGET_WAIT_FORCE_EXEC -eq 1 ]; then 
    echo "Timeout reached AND forced execution active => success"
    TARGET_FILE_RECEIVED=1
fi


if [ $TARGET_FILE_RECEIVED -eq 0 ]; then 
    echo "Timeout reached and no file found => aborted"
    exit 1
fi

exit 0